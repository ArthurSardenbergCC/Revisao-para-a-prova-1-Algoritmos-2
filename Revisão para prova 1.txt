Revisão para prova 1

Exercício 1 - Função Simples

#include <iostream>
using namespace std;

int soma (int x, int y){
    int soma = 0;
    
    soma = x + y;
    
    return soma;
}

int main(){
    int a = 2, b = 3;
    
    cout << soma (2,3) << endl;
    
    return 0;
}


Exercício 2 - Escopo da variável

#include <iostream>
using namespace std;

int numero = 8; // Variável global

void mostra_variavel_local (){
    int numero = 7; // Muda o valor de 'numero' para o escopo da função 'void' 
    
    cout << "Variável 'número' local: " << numero << endl;
    
     cout << "Variável 'número' global: " << numero << endl;
}

int main(){
    // Essa definição altera os valores das impressões abaixo, atribuindo um novo valor para 'numero' no escopo da 'main'
    //int numero = 5;  
    
    cout << "Variável 'número' da função principal: " << numero << endl;
    
    cout << "Variável 'número' global: " << numero << endl;
    
    mostra_variavel_local();
    
    return 0;
}


Exercício 3 - Protótipo e interface

#include <iostream>
using namespace std;

int fatorial (int numero);

int main(){
    
    cout << fatorial (5) << endl;

    return 0;
}


int fatorial (int numero){
    int f = 1, i = 0;
    
    for (i = 1; i <= numero ; i++){
        f *= i; 
    }
    
    return f;
}


Exercício 4 - Ponteiro básico

#include <iostream>
using namespace std;

int main(){
    int *ponteiro = NULL, x = 10;
    
    ponteiro = &x;
    cout << *ponteiro << endl;
    
    return 0;
}


Exercício 5 - Passagem por valor

#include <iostream>
using namespace std;

void soma (int numero){
    numero += 2;
}

int main(){
    int x = 5;
    
    cout << "Valor original: " << x << endl;
    soma (x);
    
    cout << "Valor após a chamada: " << x << endl;
    
    return 0;
}


Exercício 6 - Passagem por referência

#include <iostream>
using namespace std;

void soma (int &numero){
    numero += 2;
}

int main(){
    int x = 5;
    
    cout << "Valor original: " << x << endl;
    soma (x);
    
    cout << "Valor após a chamada: " << x << endl;
    
    return 0;
}


Exercício 7 - Passagem de vetor por parâmetro

#include <iostream>
using namespace std;

int soma_elementos_vetor (int V[], int n){
    int i = 0, soma = 0;
    
    for (i = 0; i < n; i++){
        soma += V[i];
    }
    
    return soma;
}

int main(){
    int V[] = {1, 2, 3};

    cout << "Soma dos elementos: " << soma_elementos_vetor (V, 3) << endl;
    
    return 0;
}


Exercício 8 - Passagem de matriz por parâmetro

#include <iostream>
#define N 3
using namespace std;

void imprimir_matriz (int matriz[N][N], int linha, int coluna){
    int i = 0, j = 0, soma = 0;
    
    for (i = 0; i < linha; i++){
        for (j = 0; j < coluna; j++){
            cout << matriz [i] [j] << " ";
        }
        cout << endl;
    }
    
}

int main(){
    int V [N] [N] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

    imprimir_matriz(V, N, N);
    
    return 0;
}


Exercício 9 - Registro ou struct

#include <iostream>
using namespace std;

typedef struct{
    string nome;
    int idade = 0;
} Pessoa;

int main(){
    Pessoa pessoa_1 = {"José", 40};

    cout << "Nome: " << pessoa_1.nome << endl;
    cout << "Idade: " << pessoa_1.idade << endl;
    
    return 0;
}


Exercício 10 - Ponteiro para registro

#include <iostream>
using namespace std;

typedef struct{
    string nome;
    int idade = 0;
} Pessoa;

int main(){
    Pessoa pessoa_1 = {"José", 40}, *ponteiro_registro = NULL;
    
    ponteiro_registro = &pessoa_1;

    cout << "Nome: " << ponteiro_registro->nome << endl;
    cout << "Idade: " << ponteiro_registro->idade << endl;
    
    return 0;
}


Exercício 11 - Registro como parâmetro (valor)

#include <iostream>
using namespace std;

typedef struct{
    string nome;
    int idade = 0;
} Pessoa;

void imprimir_registro (Pessoa dados){
    cout << "Nome: " << dados.nome << endl;
}

int main(){
    Pessoa pessoa_1 = {"José", 40};
    
    imprimir_registro (pessoa_1);

    return 0;
}


Exercício 12 - Registro como parâmetro (referência)

#include <iostream>
using namespace std;

typedef struct{
    string nome;
    int idade = 0;
} Pessoa;

void mudar_registro (Pessoa &dados){
    dados.idade = 35;
}

int main(){
    Pessoa pessoa_1 = {"José", 40};
    
    cout << "Idade antes da chamada: " << pessoa_1.idade << endl;
    
    mudar_registro (pessoa_1);
    
    cout << "Idade depois da chamada: " << pessoa_1.idade << endl;

    return 0;
}


Exercício 13 - Vetor de registros

#include <iostream>
#define N 5
using namespace std;

typedef struct{
    string nome;
    int idade = 0;
} Pessoa;

int main(){
    Pessoa quantidade [N];
    int i = 0;
    
    quantidade [0] = {"José", 28};
    quantidade [1] = {"Maria", 32};
    quantidade [2] = {"João", 30};
    quantidade [3] = {"Pedro", 37};
    quantidade [4] = {"Júlia", 25};

    for (i = 0; i < N; i++){
        cout << quantidade [i].nome << endl;
    }
    
    return 0;
}


Exercício 14 - Buscando em vetor de registros

#include <iostream>
#define N 5
using namespace std;

typedef struct{
    string nome;
    int idade = 0;
    int matricula = 0;
} Pessoa;

int procurar_matricula (Pessoa *vetor_registro, int matricula_a_procurar){
    int numero_matricula = 0, i = 0;
    bool encontrado = 0;
    
    for (i = 0; i < N; i++){
        if (vetor_registro[i].matricula == matricula_a_procurar){
            numero_matricula = i;
            encontrado = 1;
            break;
        }
    }
    
    if (encontrado == 0){
        numero_matricula = -1;
    }
    
    return numero_matricula;
}

int main(){
    Pessoa quantidade [N];
    
    quantidade [0] = {"José", 28, 1};
    quantidade [1] = {"Maria", 32, 2};
    quantidade [2] = {"João", 30, 3};
    quantidade [3] = {"Pedro", 37, 4};
    quantidade [4] = {"Júlia", 25, 5};
    
    cout << "Índice do aluno com o número de matrícula pedido: "<< procurar_matricula (quantidade, 3) << endl;

    return 0;
}

Lembre-se! A estrutura "vetor_registro[i]" é interpretada pelo compilador como a operação "*(vetor_registro + i)". O valor de "vetor_registro" é o endereço recebido pelo parâmetro da função, ou seja, o endereço que o ponteiro "*vetor_registro" aponta assim que a função é chamado, que é o endereço do primeiro registro (o de José). A soma com "i" é uma aritmética de ponteiros, a qual é depois é desreferenciada pelo operador "*". Justamente por essa última operação é que o operador "." deve ser usado para acessar a matrícula, ao invés do operador "->".

A forma que a função foi escrita é uma possibilidade de percorrer o vetor na mesma chamada (sem fornecer a cada chamada o endereço do próximo registro). Outra possibilidade é eu acessar as matrículas com o operador seta. Como o ponteiro aponta para o primeiro registro, seria necessário deslocar o ponteiro a cada iteração do "for", ou seja, uma operação como "vetor_registro++".


Exercício 15 - Ponteiro para vetor de registros

#include <iostream>
#define N 5
using namespace std;

typedef struct{
    string nome;
    int idade = 0;
    int matricula = 0;
} Pessoa;

void impressao_ultimo_nome (Pessoa *vetor_registro, int tamanho_vetor){
    int i = 0;
    
    for (i = 0; i < tamanho_vetor - 1; i++){
        vetor_registro++;
    }
    
    cout << "Nome da última pessoa: " << vetor_registro->nome << endl;
}

int main(){
    Pessoa quantidade [N], *ponteiro_registro = NULL;
    
    quantidade [0] = {"José", 28, 1};
    quantidade [1] = {"Maria", 32, 2};
    quantidade [2] = {"João", 30, 3};
    quantidade [3] = {"Pedro", 37, 4};
    quantidade [4] = {"Júlia", 25, 5};
    
    ponteiro_registro = &quantidade[0];
    
    impressao_ultimo_nome (ponteiro_registro, N);

    return 0;
}


Exercício 16 - Aritmética de ponteiros (simples)

#include <iostream>
using namespace std;


int main(){
    int V [] = {1, 2, 3}, *ponteiro = NULL;
    
    ponteiro = & V[0];
    
    ponteiro = ponteiro + 2;
    
    cout << *ponteiro;

    return 0;
}


Exercício 17 - Aritmética de ponteiros (array de registros)

#include <iostream>
#define N 3
using namespace std;

typedef struct{
    string nome;
    int idade = 0;
    int matricula = 0;
} Pessoa;

int main(){
    Pessoa quantidade [N], *ponteiro_registro = NULL;
    
    quantidade [0] = {"José", 28, 1};
    quantidade [1] = {"Maria", 32, 2};
    quantidade [2] = {"João", 30, 3};

    ponteiro_registro = &quantidade[0];
    
    ponteiro_registro++;
    
    cout << "Nome da segunda pessoa: " << ponteiro_registro->nome;

    return 0;
}


Exercício 18 - Classes de armazenamento: static em função

#include <iostream>
using namespace std;


void incrementar_variavel_estatica (){
    static int contador = 0;
    contador++;
    cout << "Valor do contador: " << contador << endl;
}

int main(){
    incrementar_variavel_estatica();
    incrementar_variavel_estatica();
    incrementar_variavel_estatica();

    return 0;
}


Exercício 19 - Classe de armazenamento: extern

Arquivo principal:

#include <iostream>
using namespace std;

extern int contadorGlobal;
extern int teste();

int main(){
    
    teste();
    
    contadorGlobal = contadorGlobal + 2;
    cout << "Variável global no arquivo principal: " << contadorGlobal;
   
    return 0;
}

Arquivo auxiliar: 

#include <iostream>
using namespace std;

int contadorGlobal = 0;

int teste (){
    cout << "Variável global no arquivo auxiliar: " << contadorGlobal << endl;
    return 0;
}

Cuidado! O arquivo auxiliar não pode ter uma função nomeada como "main", pois isso resultará em um erro de compilação.

Cuidado! No Online GDB, para a classe "extern" funcionar, o arquivo auxiliar deve ser nomeado com a mesma extensão do principal. Se o arquivo principal for ".cpp", o auxiliar também deve ser ".cpp".


Exercício 20 - Combinação de ponteiro, registro e vetor

#include <iostream>
#include <climits>
#define N 5
using namespace std;

typedef struct{
    string nome;
    int idade = 0;
} Pessoa;

Pessoa* encontrar_mais_velho (Pessoa *vetor_registro, int tamanho_vetor){
    int i = 0, mais_velho = INT_MIN;
    Pessoa *vetor_auxiliar = NULL;
    
    for (i = 0; i < tamanho_vetor - 1; i++){
        if (vetor_registro->idade > mais_velho){
            mais_velho = vetor_registro->idade;
            vetor_auxiliar = vetor_registro;
        }
        vetor_registro++;
    }
    
    return vetor_auxiliar;
}

int main(){
    Pessoa quantidade [N], *ponteiro_registro = NULL;
    
    quantidade [0] = {"José", 28};
    quantidade [1] = {"Maria", 32};
    quantidade [2] = {"João", 30};
    quantidade [3] = {"Pedro", 37};
    quantidade [4] = {"Júlia", 25};
    
    ponteiro_registro = &quantidade[0];
    
    ponteiro_registro = encontrar_mais_velho (ponteiro_registro, N);
    
    cout << "Pessoa mais velha dos registros: " << ponteiro_registro->idade << endl;

    return 0;
}

Repare que uma função que retorne ponteiro deve ser escrita da seguinte forma: "tipo_de_retorno_da_função*".
